# Git & Git flow 컨벤션

## 왜 Git으로 변경하나요?
인터넷이 없는 곳에서 급하게 작업을 하는 상황이라고 가정했을 때 <br>
**소스를 3시간 전 시점으로 돌려야 한다면?**

Git은 소스를 3시간 전 시점으로 복구하는 것도 용이하고 레파지토리에 커밋을 할 수 있습니다.

SVN을 사용할 경우 어떨까요? <br>
SVN은 인터넷이 없는 경우 소스도 복구할 수 없을 뿐더러 레파지토리에 커밋할 수 없습니다.

또 다른 예시를 들어볼게요. <br>
두 명의 개발자가 하나의 파일을 동시에 작업을 해야한다면?

왜 그럴까요?

### Git과 SVN 비교

| 기능/특징                | Git                                        | SVN                                |
|-------------------------|--------------------------------------------|-------------------------------------|
| **버전 관리 방식**       | 분산 버전 관리 (Distributed)               | 중앙 집중식 버전 관리 (Centralized) |
| **저장소**              | 로컬 및 원격 저장소                        | 중앙 서버에서 관리                  |
| **작업 흐름**           | 로컬에서 모든 작업 가능                    | 중앙 서버를 통해 작업               |
| **브랜치 관리**         | 쉽고 빠름                                  | 복잡하고 느림                      |
| **속도**                | 빠름                                       | 네트워크 속도에 따라 다름           |
| **커밋**                | 로컬에서 커밋 후 나중에 푸시                | 바로 중앙 서버에 커밋               |
| **네트워크 의존성**     | 낮음                                       | 높음                                |
| **충돌 해결**           | 로컬에서 쉽게 해결 가능                    | 중앙 서버에서 해결                  |

gpt한테 물어봤을 때 이러한 특징들이 있다고 하는데요. <br>
제가 느끼기에 크게 2가지 **저장소와 브랜치**가 차이가 있다고 생각합니다.

![SVN과 Git의 차이](https://media.licdn.com/dms/image/C4D12AQE6yv359nGzWw/article-cover_image-shrink_600_2000/0/1598705989460?e=2147483647&v=beta&t=9CdUIjWjES1EerEhJH3XkBOfxpFdcDjFXEsb7jMDgJ0)

왼쪽이 SVN, 오른쪽이 Git 이미지입니다. <br>

Git을 사용할 경우 로컬 복사본이 저장소이기 때문에 여기에 커밋할 수 있고 소스 제어의 이점을 누릴 수 있습니다. <br>
그리고 원격 저장소에 연결이 될 경우 그 저장소에 commit(push) 할 수 있습니다. <br>

SVN은 중앙 집중식 버전 관리 즉, 레파지토리가 중앙에 집중되어 있기 때문에 아까와 같이 **네트워크가 없는 상황에서는 소스 시점을 되돌릴 수 없습니다.** <br>


그렇다면 브랜치는 뭘까요?

## Branch
**브랜치**는 독립적으로 작업할 수 있는 하나의 흐름을 말하는데요. <br>
보통은 이러한 단어들을 사용해 브랜치 이름을 생성합니다.

- **main**: 배포 가능한 상태를 유지하는 브랜치.
- **develop**: 다음 배포를 준비하는 브랜치.
- **feature**: 새로운 기능을 개발하는 브랜치.
- **release**: 배포 준비를 위한 브랜치.
- **hotfix**: 긴급 수정이 필요한 경우 사용하는 브랜치.

## 주요 Git 명령어
- **git clone**: 원격 저장소를 복제.
- **git add**: 변경된 파일을 스테이징 영역에 추가.
- **git commit**: 스테이징 영역의 변경 사항을 기록. `(로컬 저장소)`
- **git fetch**: 원격 저장소의 변경 사항을 로컬로 가져옴 (병합하지 않음).
- **git push**: 로컬 커밋을 원격 저장소에 업로드. `(원격 저장소)`
- **git pull**: 원격 저장소의 변경 사항을 로컬로 가져옴.
- **git branch**: 새로운 브랜치 생성.
- **git merge**: 브랜치를 병합.

### Git에 대해서는 이해했는데 그럼 Git Flow는 뭔가요?

## Git flow
- Git Flow는 브랜치를 체계적으로 관리하여 개발 프로세스를 효율적으로 운영하는 방법론입니다.

- **브랜치 구조**:
  - `main`: 안정적인 배포 버전.
  - `develop`: 개발 중인 버전.
  - `feature/*`: 기능 개발 브랜치.
  - `release/*`: 배포 준비 브랜치.
  - `hotfix/*`: 긴급 수정 브랜치.

서비스 기업에서는 보통 5가지 브랜치 구조를 활용하지만 제가 생각했을 때 저희는 릴리즈까지는 사용하지 않고 `main`, `develop`, `feature`를 주로 사용하게 될 것 같습니다.

## 꼭 Git을 사용할 때는 브랜치 전략을 사용해야 하나요?
Git을 사용할 때 브랜치 전략을 반드시 사용해야 하는 것은 아니지만, 협업이 많은 프로젝트에서는 큰 이점을 제공합니다. <br>
개인적인 생각으로는 브랜치 전략이 없다면 중구난방으로 브랜치가 관리되어 충돌이 날 확률이 크다고 생각합니다.

## Git flow, Github flow, GitLab flow
### Git Flow
- **브랜치 구조**:
  - `main`: 최종 배포 버전.
  - `develop`: 다음 배포를 준비하는 개발 버전.
  - `feature/*`: 새로운 기능을 개발하는 브랜치.
  - `release/*`: 배포 준비를 위한 브랜치.
  - `hotfix/*`: 긴급 수정이 필요한 경우 사용하는 브랜치.
- **특징**: 고정된 브랜치 모델을 사용하여 복잡한 프로젝트에 적합.

### Github Flow
- **브랜치 구조**:
  - `main`: 모든 변경 사항이 병합되는 기본 브랜치.
  - 기능 개발을 위한 별도의 브랜치 (예: `feature-branch`)에서 작업 후 PR(Pull Request)로 `main`에 병합.
- **특징**: 단순한 브랜치 모델로, 모든 작업이 `main`에서 파생된 브랜치에서 이루어지며 PR을 통해 병합.

### GitLab Flow
- **브랜치 구조**:
  - `main`: 최종 배포 버전.
  - `master`: 개발이 이루어지는 기본 브랜치.
  - `production`: 배포 브랜치.
  - `pre-production` (optional): 사전 배포 브랜치.
  - `feature/*`: 새로운 기능 개발 브랜치.
- **특징**: 환경별 브랜치를 추가하여 배포 환경에 맞춘 브랜치 관리.

### 이 중에서 왜 굳이 Git Flow를 사용할까요?
Git Flow가 다른 브랜치 전략에 비해 절대적으로 우월한 것은 아니지만 Git Flow가 복잡한 프로젝트에서의 체계적인 브랜치 관리와 안정성을 제공하기 때문인지 대부분의 사람들이 Git Flow을 많이 사용하는 것 같습니다.

```
master, develop ➡️ 항상 유지되는 메인 브랜치들
feature, release, hotfix ➡️ 일정 기간 동안만 유지되는 보조 브랜치들
```

## PR(Pull Request)
### PR이란?
- PR은 변경 사항을 코드 리뷰를 통해 병합하는 절차.
- 팀원 간의 코드 검토와 피드백을 통해 코드 품질을 유지.


## 제로파트 Git & Git flow 컨벤션
### 브랜치 네이밍 규칙
- `feature/설명`
- `hotfix/설명`

### 커밋 메시지 규칙
- **형식**: `태그: 설명`
- **예시**: `feat: 사용자 로그인 기능 추가`

## 커밋 메시지 규칙 상세화
### 태그 목록
- **feat**: 새로운 기능 추가.
- **fix**: 버그 수정.
- **docs**: 문서 수정.
- **style**: 코드 포맷팅, 세미콜론 누락 등 비즈니스 로직에 영향을 주지 않는 변경.
- **refactor**: 코드 리팩토링.
- **test**: 테스트 코드 추가.
- **chore**: 기타 변경 사항.


### 새로운 기능도 구현하고 기존 코드 버그 수정도 했을 땐?
(commit 메세지에 feat이라고 써야 할까요 아님 fix라고 써야할까요?)
- 이런 경우에는 멀티 커밋을 사용하는 것이 좋습니다. 즉, 각각의 변경 사항에 대해 개별 커밋을 만듭니다.
  - 예시:
      - [feat] 사용자 로그인 기능 추가 (#123)
      - [fix] 로그인 시 발생하던 버그 수정 (#124)


### .gitignore
- **.gitignore 파일**은 Git이 추적하지 않을 파일 또는 디렉토리를 지정합니다.
* .gitignore에는 target이나 .idea 등 불 필요한 폴더들을 git changes에 올라가지 않게 할 수 있는데요.
중요한 점은 **.gitignore 파일은 꼭 원격 저장소에 포함이 되어있어야 한다는 점**입니다.



이외에 git flow 초기 설정, PR을 올리는 방법은 PPT를 참고해주세요. <br>
```
G:\공유 드라이브\120.EZ\[01] 공통\[998] 에너지사업부\제로에너지 git & git flow 그리고 컨벤션_전희진.pptx
```